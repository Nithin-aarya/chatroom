<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Chat Room</title>
  <style>
    body { margin:0; font-family: system-ui, Arial, sans-serif; background:#000; overflow:hidden; }
    #canvas { width:100vw; height:100vh; }
    #username-modal { position:fixed; inset:0; background:rgba(0,0,0,.8); display:flex; align-items:center; justify-content:center; z-index:100; }
    #username-form { background:#fff; padding:24px 28px; border-radius:12px; width:320px; text-align:center; }
    #username-input { width:100%; padding:10px; margin:10px 0; border:1px solid #ccc; border-radius:6px; }
    #username-submit { border:0; background:#0A84FF; color:#fff; padding:10px 14px; border-radius:8px; cursor:pointer; width:100%; }
    #ui { position:absolute; top:16px; left:16px; color:#fff; background:rgba(0,0,0,.6); padding:12px 14px; border-radius:10px; z-index:10; }
    #users { position:absolute; top:16px; right:16px; color:#fff; background:rgba(0,0,0,.6); padding:12px 14px; border-radius:10px; z-index:10; min-width:160px; }
    #users h4 { margin:0 0 6px 0; font-weight:600; }
    #users-list div { opacity:.9; margin:2px 0; }
    #chat { position:absolute; bottom:16px; left:16px; width:400px; height:220px; display:flex; flex-direction:column; background:rgba(0,0,0,.75); border-radius:12px; overflow:hidden; z-index:10; }
    #modes { padding:6px; display:flex; gap:6px; }
    .mode-btn { font-size:12px; border:1px solid #666; background:rgba(0,0,0,.6); color:#fff; padding:4px 8px; border-radius:6px; cursor:pointer; }
    .mode-btn.active { background:#0A84FF; border-color:#0A84FF; }
    #messages { flex:1; overflow-y:auto; padding:8px 10px; color:#fff; font-size:14px; }
    .message { margin:4px 0; padding:4px 8px; border-radius:6px; background:rgba(255,255,255,.08); }
    .message .username { font-weight:700; margin-right:6px; }
    #input-area { display:flex; gap:8px; padding:8px; border-top:1px solid #333; }
    #chat-input { flex:1; padding:8px; border-radius:6px; background:rgba(255,255,255,.12); border:1px solid #666; color:#fff; }
    #send-btn { border:0; padding:8px 10px; border-radius:6px; background:#0A84FF; color:#fff; cursor:pointer; }
    #sit-prompt { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,.7); color:#fff; padding:8px 14px; border-radius:20px; display:none; z-index:10; }
  </style>
</head>
<body>
  <!-- Join dialog -->
  <div id="username-modal">
    <div id="username-form">
      <h2>Join 3D Chat</h2>
      <input id="username-input" placeholder="Your username..." />
      <button id="username-submit">Join</button>
      <p style="font-size:12px;color:#666;margin-top:8px">WASD to move • Mouse to look • E to sit</p>
    </div>
  </div>

  <div id="canvas"></div>

  <!-- HUD -->
  <div id="ui">
    <div><b>Controls</b></div>
    <div>WASD: move</div>
    <div>Mouse: look (click scene)</div>
    <div>E: sit/stand</div>
  </div>

  <div id="users">
    <h4>Online</h4>
    <div id="users-list"></div>
  </div>

  <div id="chat">
    <div id="modes">
      <button class="mode-btn active" data-mode="normal">Normal</button>
      <button class="mode-btn" data-mode="whisper" disabled>Whisper</button>
      <button class="mode-btn" data-mode="private" disabled>Private</button>
    </div>
    <div id="messages"></div>
    <div id="input-area">
      <input id="chat-input" placeholder="Type a message…"/>
      <button id="send-btn">Send</button>
    </div>
  </div>

  <div id="sit-prompt">Press E to sit</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ====== globals ======
    let scene, camera, renderer;
    let player = { pos: new THREE.Vector3(0,1.6,5), ry: 0, sitting:false };
    let keys = {};
    let mouseYaw = 0;
    let currentUser = null; // { name, color }
    let selfId = null;

    // remote players: id -> { group, head, body, label }
    const remotes = {};
    const chairs = [];
    let nearbyChair = null;

    // ====== socket ======
    const socket = io();

    // ----- UI helpers -----
    function addMessage(type, userOrText, content='') {
      const box = document.getElementById('messages');
      const div = document.createElement('div');
      div.className = 'message';
      if (type === 'system') {
        div.innerHTML = `<em>${userOrText}</em>`;
      } else {
        div.innerHTML = `<span class="username">${userOrText}:</span> ${content}`;
      }
      box.appendChild(div);
      box.scrollTop = box.scrollHeight;
      if (box.children.length > 200) box.removeChild(box.children[0]);
    }

    function renderUserList(list) {
      const el = document.getElementById('users-list');
      el.innerHTML = '';
      list.forEach(name => el.innerHTML += `<div>${name}</div>`);
    }

    // ====== scene setup ======
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1f2a);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.copy(player.pos);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('canvas').appendChild(renderer.domElement);

      const amb = new THREE.AmbientLight(0xffffff, 0.65);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 0.5);
      dir.position.set(10,15,10);
      dir.castShadow = true;
      scene.add(dir);

      // floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshLambertMaterial({ color: 0x2b3a4a })
      );
      floor.rotation.x = -Math.PI/2;
      floor.receiveShadow = true;
      scene.add(floor);

      // table + a few chairs (static)
      const table = new THREE.Mesh(
        new THREE.BoxGeometry(6, 0.2, 3),
        new THREE.MeshLambertMaterial({ color: 0x8b5a2b })
      );
      table.position.set(0, 0.9, 0);
      table.castShadow = table.receiveShadow = true;
      scene.add(table);

      const chairPositions = [
        {x: 0, z:  3}, {x: 0, z: -3}, {x: -4, z: 0}, {x: 4, z: 0},
        {x:-3, z:  2}, {x: 3, z:  2}, {x:-3, z:-2}, {x: 3, z:-2}
      ];
      chairPositions.forEach((p,i)=>{
        const g = new THREE.Group();
        const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.1,0.8), new THREE.MeshLambertMaterial({color:0x6b4a2f}));
        seat.position.y = 0.5; g.add(seat);
        const back = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.6,0.1), new THREE.MeshLambertMaterial({color:0x6b4a2f}));
        back.position.set(0,0.8,-0.35); g.add(back);
        g.position.set(p.x,0,p.z); g.userData = { id:i, occupied:false, pos:p };
        scene.add(g); chairs.push(g);
      });

      // events
      window.addEventListener('resize', onResize);
      // mac-friendly keyboard listeners
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);

      renderer.domElement.addEventListener('click', () => {
        if (document.pointerLockElement !== renderer.domElement)
          renderer.domElement.requestPointerLock();
      });
      document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === renderer.domElement) {
          mouseYaw += e.movementX * 0.002;
        }
      });
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(e) {
      if (document.activeElement === document.getElementById('chat-input')) return;
      const k = e.key.toLowerCase();
      keys[k] = true;
      if (k === 'e' && nearbyChair) toggleSit();
    }
    function onKeyUp(e) {
      if (document.activeElement === document.getElementById('chat-input')) return;
      keys[e.key.toLowerCase()] = false;
    }

    // ====== avatars ======
    function createAvatar(colorHex) {
      const group = new THREE.Group();

      // body (cylinder)
      const body = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.45, 1.2, 12),
        new THREE.MeshLambertMaterial({ color: colorHex })
      );
      body.position.y = 0.6;
      body.castShadow = body.receiveShadow = true;
      group.add(body);

      // head (sphere)
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.28, 16, 16),
        new THREE.MeshLambertMaterial({ color: 0xf2dcc5 })
      );
      head.position.y = 1.4;
      head.castShadow = true;
      group.add(head);

      // name label (simple sprite-ish plane)
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,256,64);
      ctx.fillStyle = '#ffffff'; ctx.font = '28px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      // text drawn later when we know the name
      const tex = new THREE.CanvasTexture(canvas);
      const label = new THREE.Mesh(
        new THREE.PlaneGeometry(1.4, 0.35),
        new THREE.MeshBasicMaterial({ map: tex, transparent: true })
      );
      label.position.set(0, 1.9, 0);
      label.renderOrder = 999;
      group.add(label);

      group.userData = { labelCanvas: canvas, labelCtx: ctx, labelTex: tex, labelMesh: label };
      return { group, body, head };
    }

    function setAvatarName(avatar, name) {
      const { labelCanvas, labelCtx, labelTex } = avatar.group.userData;
      labelCtx.clearRect(0,0,labelCanvas.width,labelCanvas.height);
      labelCtx.fillStyle = 'rgba(0,0,0,0.6)'; labelCtx.fillRect(0,0,labelCanvas.width,labelCanvas.height);
      labelCtx.fillStyle = '#ffffff';
      labelCtx.font = '28px Arial';
      labelCtx.textAlign = 'center'; labelCtx.textBaseline = 'middle';
      labelCtx.fillText(name, labelCanvas.width/2, labelCanvas.height/2);
      labelTex.needsUpdate = true;
    }

    function addRemoteUser(id, name, color, state) {
      if (remotes[id]) return;
      const avatar = createAvatar(color);
      scene.add(avatar.group);
      setAvatarName(avatar, name);
      avatar.group.position.set(state?.x ?? 0, 0, state?.z ?? 0);
      avatar.group.rotation.y = state?.ry ?? 0;
      remotes[id] = { name, color, ...avatar };
    }

    function removeRemoteUser(id) {
      const r = remotes[id];
      if (!r) return;
      scene.remove(r.group);
      if (r.group.material?.map) r.group.material.map.dispose?.();
      delete remotes[id];
    }

    // ====== gameplay ======
    function updatePlayer() {
      if (player.sitting) return;

      const speed = 0.1;
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const right   = new THREE.Vector3(1, 0,  0).applyQuaternion(camera.quaternion);
      forward.y = 0; right.y = 0; forward.normalize(); right.normalize();

      const move = new THREE.Vector3();
      if (keys['w']) move.add(forward);
      if (keys['s']) move.sub(forward);
      if (keys['a']) move.sub(right);
      if (keys['d']) move.add(right);
      move.normalize().multiplyScalar(speed);
      player.pos.add(move);

      // bounds
      player.pos.x = Math.max(-18, Math.min(18, player.pos.x));
      player.pos.z = Math.max(-18, Math.min(18, player.pos.z));

      camera.position.copy(player.pos);
      camera.rotation.y = mouseYaw;

      checkChairs();
    }

    function checkChairs() {
      nearbyChair = null;
      let min = 2;
      for (const c of chairs) {
        const d = player.pos.distanceTo(c.position);
        if (d < min) { min = d; nearbyChair = c; }
      }
      const prompt = document.getElementById('sit-prompt');
      if (nearbyChair && !player.sitting) { prompt.style.display='block'; prompt.textContent='Press E to sit'; }
      else if (player.sitting) { prompt.style.display='block'; prompt.textContent='Press E to stand'; }
      else prompt.style.display='none';
    }

    function toggleSit() {
      player.sitting = !player.sitting;
      player.pos.y = player.sitting ? 1.1 : 1.6;
    }

    // ====== UI wiring ======
    function setupUI() {
      const submit = document.getElementById('username-submit');
      const input  = document.getElementById('username-input');
      const chatInput = document.getElementById('chat-input');
      const sendBtn  = document.getElementById('send-btn');

      submit.onclick = () => {
        const name = input.value.trim();
        if (!name) return;
        const color = Math.floor(Math.random()*0xffffff);
        currentUser = { name, color };
        player.pos.set(0,1.6,5);
        camera.position.copy(player.pos);
        document.getElementById('username-modal').style.display = 'none';
        socket.emit("setUsername", { name, color });
      };
      input.addEventListener('keypress', e => { if (e.key === 'Enter') submit.click(); });

      sendBtn.onclick = () => {
        const msg = chatInput.value.trim();
        if (!msg) return;
        socket.emit("chatMessage", msg);
        chatInput.value = '';
      };
      chatInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendBtn.click(); });

      document.querySelectorAll('.mode-btn').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          document.querySelector('.mode-btn.active').classList.remove('active');
          btn.classList.add('active');
        });
      });
    }

    // ====== networking events ======
    socket.on("init", ({ selfId: id, users }) => {
      selfId = id;
      // spawn everyone else
      for (const [uid, u] of Object.entries(users)) {
        if (uid === selfId) continue;
        addRemoteUser(uid, u.name, u.color, u.state);
      }
      addMessage("system", "Connected. Use WASD to move.");
    });

    socket.on("userJoined", ({ id, name, color, state }) => {
      addRemoteUser(id, name, color, state);
      addMessage("system", `${name} joined!`);
    });

    socket.on("removeUser", (id) => {
      const r = remotes[id];
      if (r) addMessage("system", `${r.name} left.`);
      removeRemoteUser(id);
    });

    socket.on("updateUserList", (list) => renderUserList(list));

    socket.on("chatMessage", ({ user, msg }) => {
      addMessage("normal", user, msg);
    });

    socket.on("stateUpdate", ({ id, state }) => {
      const r = remotes[id];
      if (!r) return;
      r.group.position.set(state.x, 0, state.z);
      r.group.rotation.y = state.ry;
    });

    // send our state 15 times/sec
    setInterval(() => {
      if (!currentUser) return;
      socket.emit("state", {
        x: player.pos.x, y: player.pos.y, z: player.pos.z,
        ry: camera.rotation.y,
        sitting: player.sitting
      });
    }, 66);

    // ====== main loop ======
    function animate() {
      requestAnimationFrame(animate);
      if (currentUser) updatePlayer();

      // make all name labels face camera
      for (const r of Object.values(remotes)) {
        r.group.userData.labelMesh.lookAt(camera.position);
      }

      renderer.render(scene, camera);
    }

    // boot
    initScene();
    setupUI();
    animate();
  </script>
</body>
</html>
